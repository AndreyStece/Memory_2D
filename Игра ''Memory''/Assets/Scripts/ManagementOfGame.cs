using System.Collections;
using System.Collections.Generic;
using UnityEngine;
// UnityEngine - это библиотека, которая подключает различные инструменты и функции,
// предназначенные для работы с игровым взаимодействием в Unity
using UnityEngine.UI;
using UnityEngine.SceneManagement;
// UnityEngine.SceneManagement - это библиотека, которая подключает инструменты и функции 
// для "управления сценами игры"(SceneManagement)

public class ManagementOfGame : MonoBehaviour
{
    #region Приостановка текущей игры
    public void Stop()
    // Метод Stop вызывается для приостановки текущей игры, чтобы поставить игру на паузу
    {
        Time.timeScale = 0;
        // Time.timescale отвечает за приостановку или возобновление игрового взаимодействия
        // При выбранном значении "0" игра ставится на паузу
        Pause.SetActive(true);
        // SetActive отвечает за скрытие или показ той или иной панели
        // При выбранном значении "true" открывается панель Pause,
        // которая становится действительной при нажатии кнопки "Выход"
    }
    #endregion

    #region Возврат или выход из текущей игры
    public void Desires(int i)
    // Метод Desires вызывается для осуществления какого-либо действия, совершенного пользователем при остановке игры
    {
        Time.timeScale = 1;
        // Time.timescale отвечает за приостановку или возобновление игрового взаимодействия
        // При выбранном значении "1" игра вновь возобновляется

        switch (i)
        // Функция, которую запрашивает пользователь, нажав какую-то из показанных ему кнопок,
        // выбирается и осуществляется только по числовому значению данной кнопки, которой и соответствует эта функция
        {
            case (0):
                SceneManager.LoadScene("Menu Of Game");
                // При нажатии кнопки "Вернуться в главное меню" осуществляется загрузка новой сцены(SceneManager.LoadScene) 
                // и переход к главному игровому меню("Menu of Game")
                break;
            case (1):
                SceneManager.LoadScene("Single Mode");
                // При нажатии кнопки "Одиночный режим" осуществляется загрузка новой сцены(SceneManager.LoadScene) 
                // и переход к выбору уровня сложности("Single Mode")
                break;
            case (2):
                Pause.SetActive(false);
                // SetActive отвечает за скрытие или показ той или иной панели
                // При выбранном значении "false" скрывается панель Pause,
                // которая становится не действительной при нажатии кнопки "Возврат к текущей игре"
                break;
            default:
                break;
        }
    }
    #endregion

    #region Переход в главное меню или к выбору уровня сложности при завершении текущей игры
    public void Finish(int i)
    // Метод Finish вызывается для осуществления какого-либо действия, совершенного пользователем при завершении игры
    {
        Time.timeScale = 1;
        // Time.timescale отвечает за приостановку или возобновление игрового взаимодействия
        // При выбранном значении "1" игра вновь возобновляется

        switch (i)
        // Функция, которую запрашивает пользователь, нажав какую-то из показанных ему кнопок,
        // выбирается и осуществляется только по числовому значению данной кнопки, которой и соответствует эта функция
        {
            case (0):
                    SceneManager.LoadScene("Menu Of Game");
                    // При нажатии кнопки "Вернуться в главное меню" осуществляется загрузка новой сцены(SceneManager.LoadScene) 
                    // и переход к главному игровому меню("Menu of Game")
                break;
            case (1):
                    SceneManager.LoadScene("Single Mode");
                    // При нажатии кнопки "Одиночный режим" осуществляется загрузка новой сцены(SceneManager.LoadScene) 
                    // и переход к выбору уровня сложности("Single Mode")
                break;
            default:
                break;
        }
    }
    #endregion

    #region Изменяемые переменные
    public GameObject Pause;
    // Панель Pause открывается при остановке текущей игры
    public GameObject Winner;
    // Панель Winner открывается при выигрыше игрока
    public GameObject Loser;
    // Панель Loser открывается при проигрыше игрока
    public Text Timer;
    // Текст Timer определяется с помощью установки времени и вслед за временем каждый раз обновляется
    private float Label;
    // Метка Label используется для определения времени игры, зависящая от уровня сложности самой игры
    private float Times;
    // Значение Times используется в качестве таймера для установки времени
    private bool Zed;
    // Значение Zed отвечает за первоначальную инициализацию и рандомное распределение карточек в игре
    private bool[] DKey;
    // Массив DKey состоит из булевских значений, которые соответствуют данным карточкам и 
    // показывают какие из этих карточек уже имют свои числовые значения
    private bool Key;
    // Значение Key определяет, имеет ли карточка из массива DKey свое числовое значение или нет
    private int Number;
    // Значение Number определяет индекс карточки в массиве булевских значений DKey
    public GameObject[] CardsOfGame;
    // Игровые объекты CardsOfGame являются карточками самой игры
    public Sprite[] FaceOfCards;
    // Изображения лицевых(передних) сторон карточек
    public Sprite BackOfCard;
    // Изображение обратной(задней) стороны карточек
    List<int> Digit;
    // Лист Digit содержит в себе только 2 индекса карточек, которые были выбраны в самой игре
    private bool Jey;
    // Значение Jey определяется за счет сравнения двух выделенных карточек
    private int Pairs;
    // Значение Pairs определяет количество нераскрывшихся пар карточек
    public Text CloseCards;
    // Текст CloseCards определяется с помощью количества нераскрывшихся пар Pairs
    #endregion

    #region Инициализация переменных при запуске игры
    // Use this for initialization
    void Start()
    // Встроенный метод Start используется для инициализация переменных при запуске игры
    {
        Pause.SetActive(false);
        Winner.SetActive(false);
        Loser.SetActive(false);
        // SetActive отвечает за скрытие или показ той или иной панели
        // При выбранном значении "false" панели скрываются
        Label = Mathf.Round(CardsOfGame.Length / 8) - 1;
        // Значение Label означает количество минут в таймере и зависит от выбора уровня сложности игры,
        // чем выше уровень сложности, тем больше значение Label
        Times = 59;
        // Значение Times означает начало отсчета новой минуты с позиции 59 секунд
        Zed = true;
        // Значение Zed(true) означает, что доступ к первоначальной инициализации карточек разрешен
        DKey = new bool[CardsOfGame.Length];
        // Размер массива DKey равняется общему количеству всех карточек
        for (int i = 0; i < CardsOfGame.Length; i++)
        { DKey[i] = false; }
        // Каждому из элементов массива булевских значений DKey присвоено первоначальное значение false,
        // так как все игровые карточки еще не получили своих числовых значений 
        Digit = new List<int>();
        // Инициализируем Digit как новый лист
        Jey = false;
        // При запуске игры сравнения двух карточек не осуществлялось, поэтому значение Jey равно false
        Pairs = CardsOfGame.Length / 2;
        // Количество нераскрывшихся пар карточек Pairs равно половине карточек из общего числа CardsOfGame
    }
    #endregion

    #region Методы, вызывающийся один раз за кадр
    // Update is called once per frame
    void Update()
    // Встроенный метод Update вызывается один раз за кадр
    {
        #region Установка таймера
        if (Label <= 0 && Mathf.Round(Times) == 0)
        // Если значение Label меньше или равно 0 и если вышло время таймера, то...
        {
            Loser.SetActive(true);
            // SetActive отвечает за скрытие или показ той или иной панели
            // При выбранном значении "true" открывается панель Loser,
            // которая становится действительной при проигрыше игрока
        }
        else
        // Если игра еще не закончена, тогда таймер продолжает работать
        {
            Times -= Time.deltaTime;
            // Time.deltaTime отвечает за само время таймера и 
            // вычитает 1 секунду при каждом вызове метода Update 
        }

        // Построение таймера и красивое оформление вывода времени в игре
        if (Times > 10)
        {
            Timer.text = "Время: " + (Mathf.Round((Times + 30) / 60) - 1 + Label) + ":" + Mathf.Round(Times);
        }
        else if (Times <= 9.5 && Times >= 0)
        {
            Timer.text = "Время: " + (Mathf.Round((Times + 30) / 60) - 1 + Label) + ":0" + Mathf.Round(Times);
        }
        else if (Label != 0 && Times < -0.5)
        // Если значение Label не равно 0 и прошла 1 минута, то начинаем новый отсчет следующей минуты
        {
            Timer.text = "Время: " + Label + ":00";
            Times = 59.5f;
            Label--;
        }
        #endregion

        if (Zed)
        // Если значение Zed равно true, тогда переходим к инициализации и распределению карточек
        { LoadingValuesImages(); }

        if (Input.GetMouseButtonUp(0))
        // Если была нажата левая кнопка мыши, тогда переходим к выделению выбранной карточки
        { EductionOfCards(); }
    }
    #endregion

    #region Инициализация значений лицевых сторон для карточек игры
    void LoadingValuesImages()
    // Метод LoadingValuesImages вызывается всего лишь один раз за игру для 
    // первоначальной инициализации и рандомного распределения карточек в игре
    {
        for (int i = 0; i < 2; i++)
        // Распределение значений для двух половин из всего количества карточек поочередно
        {
            for (int j = 1; j < (CardsOfGame.Length) / 2 + 1; j++)
            // Переменная j отвечает за половину карточек и также является самим числовым значением для них
            {
                Key = true;
                while (Key)
                // Пока не найдена карточка, которой не присвоено числовое значение, возобновляем цикл
                {
                    Number = Random.Range(0, CardsOfGame.Length);
                    // Random.Range используется для выбора рандомного индекса карточки из массива DKey,
                    // чтобы потом этой рандомной карточки присвоить значение j
                    Key = DKey[Number];
                    // Если эта карточка уже имеет свое числовое значение и ее значение в массиве равно true,
                    // тогда продолжаем искать оставшиеся карточки, которые еще эти значения не приобрели
                }

                CardsOfGame[Number].GetComponent<Cards>().SValueOfCard = j;
                // Присваиваем значению SValueOfCard из класса Cards значение j карточки
                // с индексом Number из общего числа карточек CardsOfGame
                DKey[Number] = true;
                // После того, как выбранная карточка получила свое числовое значение,
                // значение этой карточки в массиве равняется true
            }
        }

        foreach (GameObject Card in CardsOfGame)
        // Для каждой карточки Card из общего числа карточек CardsOfGame
        // вызывается метод Images из класса Cards для присвоения изображения лицевой(передней) стороны 
        // и изображения обратной(задней) стороны карточки
        { Card.GetComponent<Cards>().Images(); }

        if (Zed)
        // Если доступ был разрешен и инициализация карточек прошла успешно,
        // то доступ к повторной инициализации становится закрытым и значение Zed равняется false 
        { Zed = false; }
    }
    #endregion

    #region Получение текстур для карточек
    public Sprite LoadingFaceOfCards(int i)
    // Метод LoadingFaceOfCard отвечает за возвращение изображения лицевой(передней) стороны карточки 
    // за счет ее числового значения i
    { return FaceOfCards[i - 1]; }

    public Sprite LoadingBackOfCard()
    // Метод LoadingBackOfCard отвечает за возвращение изображения обратной(задней) стороны карточки
    { return BackOfCard; }
    #endregion

    #region Выделение 2-х выбранных карточек
    void EductionOfCards()
    // Метод EductionOfCards вызывается при каждом нажатии левой кнопки мыши на карточку 
    // и отвечает за выделение только двух выбранных карточек
    {
        Digit = new List<int>();
        // Инициализируем Digit как новый лист
        for (int i = 0; i < CardsOfGame.Length; i++)
        // Перебор всех карточек текущей игры
        {
            if (CardsOfGame[i].GetComponent<Cards>().SKey == true && CardsOfGame[i].GetComponent<Cards>().SJey == false)
            // Если эта карточка была выбрана, и она не является раскрытой, тогда...
            {
                print(CardsOfGame[i].GetComponent<Cards>().SKey);
                Digit.Add(i);
                // Добавления индекса i выделенной карты в лист Digit
            }
        }

        if (Digit.Count == 2)
        // Если были выделены две карточки, тогда вызывается метод CompareOfCards для их сравнения
        // с передачей листа Digit
        { CompareOfCards(Digit); }
    }
    #endregion

    #region Сравнение значений 2-х выбранных карточек
    void CompareOfCards(List<int> Digit)
    // Метод CompareOfCards вызывается, если имеются две выделенные карточки,
    // и отвечает за сравнение этих карточек между собой
    {
        Jey = false;
        // Сравнения двух карточек не осуществлялось, поэтому значение Jey равно false
        Cards Net = new Cards();
        // Переменная класса Cards 
        Net.SZed = false;
        // При сравнении двух выделенных карточек доступ к перелистыванию карточек запрещен,
        // поэтому значение Zed из класса Cards равно false
        if (CardsOfGame[Digit[0]].GetComponent<Cards>().SValueOfCard == CardsOfGame[Digit[1]].GetComponent<Cards>().SValueOfCard)
        // Если две выделенные карточки равны, тогда...
        {
            Jey = true;
            // Эти карточки равны, и поэтому значение Jey равно true
            Pairs--;
            // Количество нераскрывшихся пар карточек Pairs уменьшается на 1
            CloseCards.text = "Количество не раскрывшихся пар: " + Pairs;

            if (Pairs == 0)
            // Если количество нераскрывшихся пар Pairs равно 0, тогда...
            {
                Time.timeScale = 0;
                // Time.timescale отвечает за приостановку или возобновление игрового взаимодействия
                // При выбранном значении "0" останавливается таймер и завершается игра
                Winner.SetActive(true);
                // SetActive отвечает за скрытие или показ той или иной панели
                // При выбранном значении "true" открывается панель Winner,
                // которая становится действительной при выигрыше игрока
            }
        }
        else
        // Если две выделенные карточки не равны, тогда эти карточки перестают быть выделеными,
        // и поэтому значения SKey из класса Cards равны false
        {
            CardsOfGame[Digit[0]].GetComponent<Cards>().SKey = false;
            CardsOfGame[Digit[1]].GetComponent<Cards>().SKey = false;
        }

        for (int i = 0; i < Digit.Count; i++)
        // Для каждой карточки из листа Digit выполняется:
        {
            CardsOfGame[Digit[i]].GetComponent<Cards>().SJey = Jey;
            // Результат сравнения Jey присваивается SJey из класса Cards
            CardsOfGame[Digit[i]].GetComponent<Cards>().CheckPoint();
            // Для выбранной карточки вызывается метод CheckPoint,
            // который влияет на дальнейшее развитие игры 
        }
    }
    #endregion
}